GM_xmlhttpRequest({
    method: "GET",
    url: "https://pastebin.com/raw/nrnzmj9r",
    onload: function(response) {
        if (response.status == 200) {
            var users = response.responseText.split('\n'); // Assuming each user is in a new line
            var user = sessionStorage.getItem('Oxide');
            if (user && users.some(u => u.includes(user))) {
                sessionStorage.removeItem('Oxide');


(function() {
    'use strict';

    let menuContainer = null;
    let removedElement = null;
    let isStreamerModeOn = false;
    let currentMethodIndex = 0;
    let crashEspMenuVisible = false;
    let crashEspMenu = null;
    let settingsMenu = null;
    let bgColorPickerInput = null;
    let lightColorPickerInput = null;
    let mainMenuBgColor = '#0000'; // Default background color for the main menu
    let mainMenuLightColor = '#fff'; // Default light color for the main menu

    const safeSpotIndicesSets = [
        [23, 17, 5, 7], // Method 1: Predict safe spots at positions 1, 3, 5, 7
        [19, 22, 1, 3], // Method 2: Predict safe spots at positions 2, 4, 6, 8
        [1, 9, 21, 19], // Method 3: Predict safe spots at positions 3, 6, 9, 12
        [7, 5, 9, 15], // Method 4: Predict safe spots at positions 1, 5, 9, 13
        [1, 9, 10, 14], // Method 5: Predict safe spots at positions 2, 6, 10, 14
        [4, 8, 12, 16], // Method 6: Predict safe spots at positions 4, 8, 12, 16
        [5, 7, 9, 15], // Method 7: Predict safe spots at positions 3, 7, 10, 15
    ];

    function promptForKey() {

            removeElements();
            createMenu();
            blurElement('#__next > div:nth-child(2) > header');
            blurElement('#__next > div.layout_layout__JvcqL > div > div.layout_layoutChat__ksWYR > aside');
            blurElement('#__next > div:nth-child(2) > div > div > div:nth-child(2) > div');
            blurElement('#__next > div.layout_layout__JvcqL > div > div.layout_layoutColumn__e9oxs > section');

            const startGameButton = document.querySelector('.button_primary__LXFHi.gameBetSubmit');
            if (startGameButton) {
                startGameButton.addEventListener('click', handleStartGame);
            }

    }

    function handleStartGame() {
    setTimeout(() => {
        const errorMessage = document.querySelector('.go3958317564');
        const gameStartButton = document.querySelector('.game-layout_gameLayout__bgIOR button');

        if (!errorMessage && !gameStartButton) {
            const nextMethodIndex = getNextMethodIndex();
            const currentLightColor = mainMenuLightColor; // Store the current light color
            predictSafeSpots(`Prediction ${nextMethodIndex + 1}`, nextMethodIndex);
            setMenuLightColor(currentLightColor); // Reapply the stored light color
            gameStartButton.removeEventListener('click', handleStartGame); // Remove the event listener after predicting safe spots
        } else if (errorMessage && errorMessage.textContent !== "An unknown fatal error occurred while trying to process your request. Are you connected to the internet?" && errorMessage.textContent !== "You cannot afford to start this game!") {
            console.log("You cannot start this game. Error:", errorMessage.textContent);
        }
    }, 2000);
}






    function getNextMethodIndex() {
        const nextIndex = currentMethodIndex % safeSpotIndicesSets.length;
        currentMethodIndex++;
        return nextIndex;
    }

    function removeElements() {
        removedElement = document.querySelector('#__next > div:nth-child(2) > div > div:nth-child(3) > aside');
        if (removedElement) {
            removedElement.remove();
        }
    }

    function revealMenu() {
        if (menuContainer) {
            menuContainer.style.display = 'block';
        }
    }

    function createMenu() {
    menuContainer = document.createElement('div');
    menuContainer.id = 'safe-spot-menu';
    menuContainer.style.position = 'fixed';
    menuContainer.style.top = '35%';
    menuContainer.style.right = '50px';
    menuContainer.style.transform = 'translateY(-50%)';
    menuContainer.style.zIndex = '9999';
    menuContainer.style.backgroundColor = mainMenuBgColor;
    menuContainer.style.padding = '20px';
    menuContainer.style.border = '2px solid #ccc';
    menuContainer.style.borderRadius = '10px';
    menuContainer.style.width = '300px';
    menuContainer.style.boxShadow = `0 0 20px ${mainMenuLightColor}`;
    menuContainer.style.fontSize = '16px';

    // Check if the current page is '/crash' before creating the CrashESP button
    if (window.location.pathname === '/crash') {
        const crashEspButton = createAlgorithmButton('Crash ESP', toggleCrashESPMenu);
        crashEspButton.id = 'crash-esp-button'; // Set id for later reference
        menuContainer.appendChild(crashEspButton);
    }

    const settingsEmoji = document.createElement('div');
    settingsEmoji.textContent = '⚙️';
    settingsEmoji.style.position = 'absolute';
    settingsEmoji.style.top = '10px';
    settingsEmoji.style.right = '10px';
    settingsEmoji.style.cursor = 'pointer';
    settingsEmoji.addEventListener('click', toggleSettings);
    menuContainer.appendChild(settingsEmoji);
    settingsEmoji.style.fontSize = '20px'; // Increase font size for a bigger settings button


    const logoContainer = document.createElement('div');
    logoContainer.style.width = '200px';
    logoContainer.style.height = '200px'; // Set height to match width for a perfect circle
    logoContainer.style.borderRadius = '50%';
    logoContainer.style.overflow = 'hidden'; // Hide overflow to maintain circle shape
    logoContainer.style.margin = '0 auto'; // Center the logo container horizontally

    const logo = document.createElement('img');
    logo.src = 'https://media.discordapp.net/attachments/1220030280039927848/1234922999098900551/LUMEN.png?ex=6634796a&is=663327ea&hm=d52c555ba29b56a88ffe805ee8bcb8fb3dca06d869df1857973953f6c4eae17f&=&format=webp&quality=lossless&width=625&height=625';
    logo.style.width = '100%'; // Ensure the image covers the container
    logo.style.height = '100%';
    logo.style.objectFit = 'cover'; // Cover the container without stretching

    logoContainer.appendChild(logo);
    menuContainer.appendChild(logoContainer);

    const header = document.createElement('h2');
    header.textContent = 'Lumen Predictor';
    header.style.textAlign = 'center';
    header.style.color = '#fff';
    header.style.fontSize = '28px';
    menuContainer.appendChild(header);

    const gameModeInfo = document.createElement('p');
    gameModeInfo.textContent = getCurrentGameMode();
    gameModeInfo.style.textAlign = 'center';
    gameModeInfo.style.color = '#fff';
    gameModeInfo.style.fontSize = '20px';
    menuContainer.appendChild(gameModeInfo);

    const algoButton = createAlgorithmButton('Mo7 Algorithm', handleMo7Algorithm);
    algoButton.id = 'algo-button'; // Set id for later reference
    menuContainer.appendChild(algoButton);

    const streamerModeButton = createButton('Streamer Mode', toggleStreamerMode);
    menuContainer.appendChild(streamerModeButton);

    document.body.appendChild(menuContainer);
}

    function handleMo7Algorithm() {
    // Remove the timeout if there's any existing one
    clearTimeout(window.mo7AlgorithmTimeout);
    // No prediction logic here
}





    function createAlgorithmButton(algorithmName, onClickHandler) {
        const button = document.createElement('button');
        button.textContent = algorithmName;
        button.style.width = '100%';
        button.style.padding = '12px';
        button.style.marginTop = '10px';
        button.style.backgroundColor = '#0000';
        button.style.color = '#fff';
        button.style.border = 'none';
        button.style.borderRadius = '5px';
        button.style.cursor = 'pointer';
        button.addEventListener('click', onClickHandler);
        return button;
    }

    function createButton(text, onClickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.width = '100%';
        button.style.padding = '12px';
        button.style.marginTop = '10px';
        button.style.backgroundColor = '#0000';
        button.style.color = '#fff';
        button.style.border = 'none';
        button.style.borderRadius = '5px';
        button.style.cursor = 'pointer';
        button.addEventListener('click', onClickHandler);
        return button;
    }

    function toggleSettings() {
    if (settingsMenu) {
        settingsMenu.remove();
        settingsMenu = null;
        createMenu(); // Reopen the main menu
    } else {
        removeMenu(); // Close the main menu
        createSettingsMenu();
    }
}



function removeMenu() {
    if (menuContainer) {
        menuContainer.remove();
        menuContainer = null;
    }
}

function createSettingsMenu() {
    // Create the settings menu
    settingsMenu = document.createElement('div');
    settingsMenu.id = 'safe-spot-menu'; // Reuse the same ID for consistent styling
    settingsMenu.style.position = 'fixed';
    settingsMenu.style.top = '35%';
    settingsMenu.style.right = '50px';
    settingsMenu.style.transform = 'translateY(-50%)';
    settingsMenu.style.zIndex = '9999';
    settingsMenu.style.backgroundColor = mainMenuBgColor;
    settingsMenu.style.padding = '20px';
    settingsMenu.style.border = '2px solid #ccc';
    settingsMenu.style.borderRadius = '10px';
    settingsMenu.style.width = '300px';
    settingsMenu.style.boxShadow = `0 0 20px ${mainMenuLightColor}`;
    settingsMenu.style.fontSize = '16px';
    settingsMenu.style.height = 'calc(55vh - 10px)'; // Adjust height to fill viewport


    // Add the settings emoji to the settings menu
    const settingsEmoji = document.createElement('div');
    settingsEmoji.textContent = '⚙️';
    settingsEmoji.style.position = 'absolute';
    settingsEmoji.style.top = '10px';
    settingsEmoji.style.right = '10px';
    settingsEmoji.style.cursor = 'pointer';
    settingsEmoji.addEventListener('click', toggleSettings);
    settingsMenu.appendChild(settingsEmoji);
    settingsEmoji.style.fontSize = '20px'; // Increase font size for a bigger settings button



    // Add content to the settings menu (color pickers, etc.)
    const bgColorPickerInput = createColorPickerInput('Background Color', mainMenuBgColor, setMenuBackgroundColor);
    settingsMenu.appendChild(bgColorPickerInput);

    const lightColorPickerInput = createColorPickerInput('Light Color', mainMenuLightColor, setMenuLightColor);
    settingsMenu.appendChild(lightColorPickerInput);

    document.body.appendChild(settingsMenu);
}




    function createColorPickerInput(label, color, onChangeHandler) {
    const container = document.createElement('div');
    container.style.marginTop = '10px';

    const nameLabel = document.createElement('label');
    nameLabel.textContent = label + ': ';
    nameLabel.style.color = '#fff';
    nameLabel.style.fontSize = '18px'; // Increase font size for the label
    nameLabel.style.fontFamily = 'Arial, sans-serif'; // Change font family for the label
    container.appendChild(nameLabel);

    const colorPickerInput = document.createElement('input');
    colorPickerInput.type = 'color';
    colorPickerInput.value = color;
    colorPickerInput.style.width = '30px'; // Decrease width for smaller input field
    colorPickerInput.style.height = '30px'; // Decrease height for smaller input field
    colorPickerInput.style.border = 'none'; // Remove border
    colorPickerInput.style.borderRadius = '5px'; // Add border radius for rounded corners
    colorPickerInput.style.cursor = 'pointer';
    colorPickerInput.addEventListener('input', (event) => onChangeHandler(event.target.value));
    container.appendChild(colorPickerInput);

    const lineContainer = document.createElement('div');
    lineContainer.style.padding = '0 5px'; // Add padding to create space on each side
    lineContainer.style.marginTop = '5px'; // Add margin to separate from color picker
    lineContainer.style.display = 'flex';
    lineContainer.style.justifyContent = 'center';

    const line = document.createElement('hr');
    line.style.width = 'calc(100% - 10px)'; // Subtract padding width to calculate line width
    line.style.border = 'none'; // Remove default border
    line.style.borderTop = '1px solid #fff'; // Add border style for the line

    lineContainer.appendChild(line);
    container.appendChild(lineContainer);

    return container;
}





    function setMenuBackgroundColor(color) {
    mainMenuBgColor = color;
    if (menuContainer) {
        menuContainer.style.backgroundColor = color;
    }
    if (crashEspMenu) {
        crashEspMenu.style.backgroundColor = color;
    }
    if (settingsMenu) {
        settingsMenu.style.backgroundColor = color;
    }
}

let selectedEdgeColor = '#fff'; // Default edge color

function setMenuLightColor(color) {
    mainMenuLightColor = color;
    selectedEdgeColor = color; // Store the selected edge color
    if (menuContainer) {
        menuContainer.style.boxShadow = `0 0 20px ${color}`;
        menuContainer.style.borderColor = color; // Update edge color as well
    }
    if (crashEspMenu) {
        crashEspMenu.style.boxShadow = `0 0 20px ${color}`;
        crashEspMenu.style.borderColor = color; // Update edge color as well
    }
    if (settingsMenu) {
        settingsMenu.style.boxShadow = `0 0 20px ${color}`;
        settingsMenu.style.borderColor = color; // Update edge color as well
    }

    // Update the edge color of green safe spots
    const greenSafeSpotButtons = document.querySelectorAll('.green-safe-spot');
    greenSafeSpotButtons.forEach(button => {
        button.style.borderColor = color; // Update the border color of green safe spots
        button.style.boxShadow = `0 0 45px ${color}`; // Update the shadow color of green safe spots
    });
}



    function toggleStreamerMode() {
        const elementsToBlur = [
            '#__next > div:nth-child(2) > header',
            '#__next > div.layout_layout__JvcqL > div > div.layout_layoutChat__ksWYR > aside',
            '#__next > div:nth-child(2) > div > div > div:nth-child(2) > div',
            '#__next > div.layout_layout__JvcqL > div > div.layout_layoutColumn__e9oxs > section'
        ];

        elementsToBlur.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                if (isStreamerModeOn) {
                    element.style.filter = 'none';
                } else {
                    element.style.filter = 'blur(5px)';
                }
            }
        });

        isStreamerModeOn = !isStreamerModeOn;
    }

    function toggleCrashESPMenu() {
        if (!crashEspMenuVisible) {
            showCrashESPMenu();
        } else {
            hideCrashESPMenu();
        }
    }

   function showCrashESPMenu() {
    crashESP();
    crashEspMenuVisible = true;
    setCrashESPMenuColor(mainMenuBgColor, mainMenuLightColor); // Set color when opened
    crashEspMenu.style.border = '2px solid ' + mainMenuLightColor; // Add border style
}

    function hideCrashESPMenu() {
        if (crashEspMenu) {
            crashEspMenu.remove();
            crashEspMenu = null;
        }
        crashEspMenuVisible = false;
        setCrashESPMenuColor('#0000', '#fff'); // Reset color when closed
    }

    function setCrashESPMenuColor(bgColor, lightColor) {
        if (crashEspMenu) {
            crashEspMenu.style.backgroundColor = bgColor;
            crashEspMenu.style.boxShadow = `0 0 20px ${lightColor}`;
        }
    }

    function crashESP() {
        fetch("https://api.bloxflip.com/games/crash")
            .then(response => response.json())
            .then(data => {
                const history = data.history;
                const superSafePrediction = calculateSuperSafePrediction(history);
                const safePrediction = calculateSafePrediction(history);
                const riskyPrediction = calculateRiskyPrediction(history, safePrediction);
                crashEspMenu = createPredictionMenu(superSafePrediction, safePrediction, riskyPrediction);
                document.body.appendChild(crashEspMenu);
                adjustCrashESPMenuPosition();
            })
            .catch(error => console.error(error));
    }

    function adjustCrashESPMenuPosition() {
        if (crashEspMenu && menuContainer) {
            const menuRect = menuContainer.getBoundingClientRect();
            const crashEspMenuRect = crashEspMenu.getBoundingClientRect();

            crashEspMenu.style.top = `${menuRect.bottom}px`;
            crashEspMenu.style.left = `${menuRect.left}px`;
            crashEspMenu.style.width = `${menuRect.width}px`;
        }
    }

    function createPredictionMenu(superSafePrediction, safePrediction, riskyPrediction) {
    const predictionMenu = document.createElement('div');
    predictionMenu.id = 'crash-esp-menu';
    predictionMenu.style.position = 'fixed';
    predictionMenu.style.zIndex = '9999';
    predictionMenu.style.backgroundColor = mainMenuBgColor; // Match the main menu background color
    predictionMenu.style.padding = '20px';
    predictionMenu.style.borderRadius = '10px';
    predictionMenu.style.boxShadow = `0 0 20px ${mainMenuLightColor}`;
    predictionMenu.style.fontSize = '16px';
    predictionMenu.style.textAlign = 'center';
    predictionMenu.style.border = `2px solid ${mainMenuLightColor}`; // Add border style

    const superSafePredictionElement = document.createElement('p');
    superSafePredictionElement.textContent = `Super Safe Prediction: ${superSafePrediction.toFixed(2)}`;
    predictionMenu.appendChild(superSafePredictionElement);

    const safePredictionElement = document.createElement('p');
    safePredictionElement.textContent = `Safe Prediction: ${safePrediction.toFixed(2)}`;
    predictionMenu.appendChild(safePredictionElement);

    const riskyPredictionElement = document.createElement('p');
    riskyPredictionElement.textContent = `Risky Prediction: ${riskyPrediction.toFixed(2)}`;
    predictionMenu.appendChild(riskyPredictionElement);

    return predictionMenu;
}


    function calculateSuperSafePrediction(history) {
        const last50Crashes = getLastNCrashes(history, 50);
        const average = calculateAverage(last50Crashes);
        return average;
    }

    function calculateSafePrediction(history) {
        const last10Crashes = getLastNCrashes(history, 10);
        const average = calculateAverage(last10Crashes);
        return average;
    }

    function calculateRiskyPrediction(history, safePrediction) {
        const volatility = calculateVolatility(history);
        return safePrediction * (1 + volatility);
    }

    function getLastNCrashes(history, n) {
        return history.slice(Math.max(history.length - n, 0));
    }

    function calculateAverage(crashes) {
        const sum = crashes.reduce((total, crash) => total + crash.crashPoint, 0);
        return sum / crashes.length;
    }

    function calculateVolatility(history) {
        const average = calculateAverage(history.map(crash => crash.crashPoint));
        const squaredDifferences = history.map(crash => Math.pow(crash.crashPoint - average, 2));
        const variance = squaredDifferences.reduce((total, squaredDifference) => total + squaredDifference, 0) / history.length;
        return Math.sqrt(variance) / 100;
    }

    function predictSafeSpots(algorithm, methodIndex) {
    const mineButtons = document.querySelectorAll('.mines_minesGameItem__S2ytQ');
    const safeSpotIndices = safeSpotIndicesSets[methodIndex];
    const currentColor = getComputedStyle(mineButtons[0]).borderColor; // Get the current border color

    // Reset all buttons to default state
    mineButtons.forEach(button => {
        button.style.border = ''; // Reset border
        button.style.boxShadow = ''; // Reset shadow
        button.classList.remove('green-safe-spot'); // Remove green safe spot class from all buttons
    });

    // Highlight safe spots with the previously selected color
    safeSpotIndices.forEach(spotIndex => {
        const button = mineButtons[spotIndex - 1]; // Adjust index since button indices start from 0
        if (button) {
            button.classList.add('green-safe-spot'); // Add class to identify green safe spots
            button.style.border = `2px solid ${currentColor}`; // Set the border color to the previously selected color
            button.style.boxShadow = `0 0 45px ${currentColor}`; // Add shadow with the same color
        }
    });
}





    function blurElement(selector) {
        const element = document.querySelector(selector);
        if (element) {
            element.style.filter = 'blur(5px)';
        }
    }

    function getCurrentGameMode() {
        const path = window.location.pathname;
        if (path.startsWith('/mines')) {
            return 'Current game: Mines';
        } else if (path === '/') {
            return 'Current game: Home';
        } else if (path.includes('/crash')) {
            return 'Current game: Crash';
        } else if (path === '/towers') {
            return 'Current game: Towers';
        } else if (path === '/roulette') {
            return 'Current game: Slide';
        } else if (path === '/plinko') {
            return 'Current game: Plinko';
        } else if (path === '/case-battles') {
            return 'Current game: Cases';
        } else if (path === '/cups') {
            return 'Current game: Cups';
        } else if (path === '/blackjack') {
            return 'Current game: Blackjack';
        } else if (path === '/jackpot') {
            return 'Current game: Roll';
        } else {
            return 'Current game: N/A';
        }
    }

    function updateGameModeInfo() {
        const gameModeInfo = document.querySelector('#safe-spot-menu > p');
        if (gameModeInfo) {
            gameModeInfo.textContent = getCurrentGameMode();
        }
    }

    function updateButtons() {
    const path = window.location.pathname;
    const algoButton = document.getElementById('algo-button');
    const crashEspButton = document.getElementById('crash-esp-button');

    // Check if the current page is Mines, then show/hide the Mo7 Algorithm button
    if (path.startsWith('/mines')) {
        if (!algoButton) {
            const algo2Button = createAlgorithmButton('Mo7 Algorithm', handleMo7Algorithm);
            algo2Button.id = 'algo-button';
            menuContainer.appendChild(algo2Button);
            const currentLightColor = mainMenuLightColor; // Store the current light color
            const nextMethodIndex = getNextMethodIndex();
            predictSafeSpots(`Mo7 Algorithm Prediction ${nextMethodIndex + 1}`, nextMethodIndex);
            setMenuLightColor(currentLightColor); // Reapply the stored light color
        }
    } else {
        if (algoButton) {
            algoButton.remove();
        }
    }

    // Check if the current page is '/crash' before creating the CrashESP button
    if (path === '/crash') {
        if (!crashEspButton) {
            const crashEspBtn = createAlgorithmButton('Crash ESP', toggleCrashESPMenu);
            crashEspBtn.id = 'crash-esp-button'; // Set id for later reference
            menuContainer.appendChild(crashEspBtn);
        }
    } else {
        if (crashEspButton) {
            crashEspButton.remove();
        }
    }
}




    promptForKey();
    setInterval(updateGameModeInfo, 1000);
    setInterval(updateButtons, 1000); // Update buttons every second

    const startButton = document.querySelector('#__next > div.layout_layout__JvcqL > div > div > div.game-layout_gameLayout__bgIOR > div.game-layout_gameLayoutColumn__q01vS.game-layout_gameLayoutColumnLeft__55fuZ > div > button');

    if (startButton) {
        startButton.addEventListener('click', handleStartButtonClick);
    }


function handleStartButtonClick() {
    const startButton = document.querySelector('#__next > div.layout_layout__JvcqL > div > div > div.game-layout_gameLayout__bgIOR > div.game-layout_gameLayoutColumn__q01vS.game-layout_gameLayoutColumnLeft__55fuZ > div > button');

    if (startButton.textContent.includes('Start new game')) {
        const currentLightColor = mainMenuLightColor; // Store the current light color
        const methodIndex = getRandomMethodIndex(); // Get a random method index
        predictSafeSpots(`Prediction ${methodIndex + 1}`, methodIndex); // Predict safe spots using the random method index
        setMenuLightColor(currentLightColor); // Reapply the stored light color
    }
}

function getRandomMethodIndex() {
    return Math.floor(Math.random() * safeSpotIndicesSets.length); // Generate a random index within the range of safeSpotIndicesSets
}







    window.addEventListener('keydown', (event) => {
        if (event.ctrlKey && event.code === 'KeyR') {
            revealMenu();
        }
    });

})();
            } else {
                alert('L Crack!');
            }
        } else {
            return;
        }
    }
});
